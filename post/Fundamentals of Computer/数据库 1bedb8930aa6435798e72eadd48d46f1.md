# 数据库

目前主流是两个类型的数据库

- 关系型数据库（SQL代表产品MySQL)：Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。因为是纯内存操作，所以Redis 的性能非常出色，是已知性能最快的 key-value 数据库。
- 非关系型数据库（NoSQL代表产品Redis）

[(99条消息) 关系型数据库和非关系型数据库的优缺点和对比_不爱睡觉的程然的博客-CSDN博客](https://blog.csdn.net/cr_lzy/article/details/94961460)

[Hadoop生态圈的核心组件包括哪些 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2082796#:~:text=1%E3%80%81%20Hbase%20%3A%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E5%88%97%E7%9A%84%E5%AD%98%E5%82%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F,%E6%95%B0%E6%8D%AE%E5%BA%93%20%EF%BC%8C%E5%85%B6%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%BAKey-Value%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BE%BF%E4%BA%8E%E6%89%A9%E5%B1%95%E5%B9%B6%E4%B8%94%E6%9F%A5%E8%AF%A2%E9%AB%98%E6%95%88%E3%80%82%202%E3%80%81Hive%EF%BC%9AHive%E6%98%AFHadoop%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%EF%BC%8C%E4%B9%9F%E6%8F%90%E4%BE%9B%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E3%80%82)

[超全的数据库分类介绍 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/101606473)

[(102条消息) 数据库种类大全及区别_seniorShen的博客-CSDN博客](https://blog.csdn.net/SeniorShen/article/details/100530709)

## MySQL

下载教程

[Windows10 MYSQL Installer 安装（mysql-installer-community-5.7.19.0.msi） | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/windows10-mysql-installer.html)

实践项目

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%201bedb8930aa6435798e72eadd48d46f1/Untitled.png)

下一步考虑部署到服务器

[小白学python爬虫：4.六十行代码爬取NBA数据 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/49947767)

### MySQL内部构造

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%201bedb8930aa6435798e72eadd48d46f1/Untitled%201.png)

****一条 SQL 语句的执行过程****

1.首先进行链接，链接时进行验证，保证安全性，查看执行权限

2.查看缓存，是否有这条语句的执行缓存，如果有缓存则直接返回缓存

3.连接器，分析器（这里查看语法是否有错误），优化器，执行器，搜索引擎

****为什么用 B+ 树做索引****

`二叉搜索树`

当数据是单调递增或递减时，则会退化成链表

`AVL树`

因为维护二叉平衡树的开销比收益要大的多，我们作为索引的数据结构，更多的要求局部，而不是非常严格的平衡的红黑树。不过对于插入较少，查找较多的场景AVL的性能还是较高的。另外AVL树的每个节点只存储一个键值和数据。

`红黑树`

红黑树是一个弱平衡树，但是随着插入数据过多，查询数据时造成的I/O消耗也是巨大的，因为我们很多时候，一次查询并不能将所有数据全部存入内存中，深度过深的话，会加大I/O开销。

B树和B+树的比较在上面

常用的几种索引类型

- 哈希索引：可以直接通过关键字查询到数据，键值对，指定查询效率更高
- 数组索引：数组索引等值查询和范围查询效果较好，但是插入新数据的时候，需要做大量移动，降低性能
- B+树索引：InnoDB的数据都是存储在B+树上的。每一个索引在InnoDB里面对应一棵B+树

最新的MySQL采用的数据引擎事InnoDB，包含两个文件进行存储

`frm` 文件（frame）存储表**结构**；

`.ibd` 文件（InnoDB Data）存储表**索引+数据**。

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%201bedb8930aa6435798e72eadd48d46f1/Untitled%202.png)

**MySQL持久化机制**

**事务**

- 特性：ACID
    
    隔离性：隔离性是通过加锁来实现的，
    
    其他三大特性主要是借助，redo log 和 undo log 来实现的。
    

**锁**

**MVCC**：多版本并发控制，这样每条记录就能够生成一个版本链，每个事务可以查看不同的版本。

**MySQL优化**

`建表优化`

- 尽量使用数字型字段，因为查询和链接时，只需比较一次，效率更快
- 尽量使用varchar少使用char，变长字段空间少，更省空间
- 对于区分度较低的索引，也就是有大量重复的索引，我们可以对其删除。

`查询优化`

- 少使用select * 语句
- 尽量少使用模糊查询 %a
- 不使用 not in ，in，这样会导致走全表索引
- 不实用 a or b 方式进行查询，会使其不走索引
- 尽量少使用子查询（因为需要创建临时表，还需要删除临时表）

`索引优化`

不要创建太多索引，多使用组合索引

对经常 order by 的语句创建索引

**保证幂等性**

一次请求和多次请求造成的结果是一样的，不会因为多次点击而产生副作用。

`高并发情况下保证幂等性`

1.对于insert操作，我们可以这样操作，先通过字段进行搜索，查看是否有该值。如果存在则执行 update或不进行操作，如果没有则 insert。

2.我们可以通过`悲观锁`来实现，我们进行修改前先对其加锁，修改完成后再对其解锁，因为我们有insert 之前先判断的习惯，所以这样就能保证幂等性。

3.使用`乐观锁`来实现，我们给数据加上版本号，修改前如果和第一次查询的版本号一致，则进行修改，同样可以保证幂等性。

4.加`唯一索引`，我们可以通过唯一索引来解决，我们第一次可以添加成功，第二次的时候则不能添加成功。

5.`建立防重表`，可以专门建立一个表，防止重复，这个表里存储的数据只有id和唯一索引的属性组，当我们能够插入防重表时，再通过防重表插入数据库。

6.`根据状态机`这个就是订单生成的位置，通过订单状态来进行一个修改。如果我们第一次修改了状态之后，第二次就无法进行一个修改。

7.通过`分布式锁`，也就是有缓存的情况，通过setnx来对缓存中数据加锁

### SQL命令的执行过程

[阿里二面: 详解一条 SQL 的执行过程 (qq.com)](https://mp.weixin.qq.com/s/OnGaqyUpB58pC2rqqzIzgw)

整体流程

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%201bedb8930aa6435798e72eadd48d46f1/Untitled%203.png)

在存储中查询数据的过程

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%201bedb8930aa6435798e72eadd48d46f1/Untitled%204.png)

1. Buffer Pool 是 MySQL 的一个非常重要的组件，因为针对数据库的增删改操作都是在 Buffer Pool 中完成的
2. Undo log 记录的是数据操作前的样子
3. redo log 记录的是数据被操作后的样子（redo log 是 Innodb 存储引擎特有）
4. bin log 记录的是整个操作记录（这个对于主从复制具有非常重要的意义）

从准备更新一条数据到事务的提交的流程描述

1. 首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中
2. 在数据被缓存到缓存池的同时，会写入 undo log 日志文件
3. 更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中
4. 完成以后就可以提交事务，在提交的同时会做以下三件事
5. （第一件事）将redo log buffer中的数据刷入到 redo log 文件中
6. （第二件事）将本次操作记录写入到 bin log文件中
7. （第三件事）将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记

至此表示整个更新事务已经完成

### InnoDB存储引擎

采用多版本并发控制（MVCC，MultiVersion Concurrency Control）来支持高并发。并且实现了四个标准的隔离级别，通过间隙锁`next-key locking`策略防止幻读的出现。

引擎的表基于聚簇索引建立，聚簇索引对主键查询有很高的性能。不过它的二级索引`secondary index`非主键索引中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。另外InnoDB的存储格式是平台独立。

InnoDB做了很多优化，比如：磁盘读取数据方式采用的可预测性预读、自动在内存中创建hash索引以加速读操作的自适应哈希索引（adaptive hash index)，以及能够加速插入操作的插入缓冲区（insert buffer)等。

InnoDB通过一些机制和工具支持真正的热备份，MySQL 的其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

### 数据库设计三范式

1范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；(只要是关系型数据库都满足1NF)

2范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；

3范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。没有冗余的数据库设计可以做到

### MySQL语言基础
[MySQL语句大全](https://www.yuque.com/bithachi/study/9c72a6a18c85251faf5fd2dabbb0a6e4)
[SQL快速参考](https://www.runoob.com/sql/sql-quickref.html)
```mysql
SELECT 语句用于从数据库中选取数据。
SELECT column1, column2, ...
FROM table_name;

SELECT DISTINCT 语句用于返回唯一不同的值。
SELECT DISTINCT column1, column2, ...
FROM table_name;

WHERE 子句用于过滤记录。
SELECT column1, column2, ...
FROM table_name
WHERE condition;
condition -> (= <> > < >= <= BETWEEN LIKE IN)

AND & OR 运算符用于基于一个以上的条件对记录进行过滤。
SELECT * FROM Websites
WHERE country='CN'
AND alexa > 50;

ORDER BY 关键字用于对结果集进行排序。
SELECT column1, column2, ...
FROM table_name
ORDER BY column1, column2, ... ASC|DESC;

INSERT INTO 语句用于向表中插入新记录。
INSERT INTO table_name (column1,column2,column3,...)
VALUES (value1,value2,value3,...);

UPDATE 语句用于更新表中的记录。
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;

DELETE 语句用于删除表中的记录。
DELETE FROM table_name
WHERE condition;

SELECT TOP 子句用于规定要返回的记录的数目。(并非所有的数据库系统都支持 SELECT TOP 语句。 MySQL 支持 LIMIT 语句来选取指定的条数数据)
SELECT column_name(s)
FROM table_name
LIMIT number;

LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。
SELECT column1, column2, ...
FROM table_name
WHERE column LIKE pattern;

通配符可用于替代字符串中的任何其他字符。
%	替代 0 个或多个字符
_	替代一个字符
[charlist]	字符列中的任何单一字符
[^charlist]
或
[!charlist]	不在字符列中的任何单一字符
MySQL 中使用 REGEXP 或 NOT REGEXP 运算符 (或 RLIKE 和 NOT RLIKE) 来操作正则表达式。
SELECT * FROM Websites
WHERE name REGEXP '^[^A-H]'

IN 操作符允许您在 WHERE 子句中规定多个值。
SELECT column1, column2, ...
FROM table_name
WHERE column IN (value1, value2, ...);

BETWEEN 操作符用于选取介于两个值之间的数据范围内的值。
SELECT column1, column2, ...
FROM table_name
WHERE column BETWEEN value1 AND value2;

通过使用 SQL，可以为表名称或列名称指定别名。
SELECT column_name AS alias_name
FROM table_name;
SELECT column_name(s)
FROM table_name AS alias_name;

SQL join 用于把来自两个或多个表的行结合起来。
INNER JOIN：如果表中有至少一个匹配，则返回行
LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行
RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行
FULL JOIN：只要其中一个表中存在匹配，则返回行

SQL UNION 操作符合并两个或多个 SELECT 语句的结果。
SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;
注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL

SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中。
注意：
MySQL 数据库不支持 SELECT ... INTO 语句，但支持 INSERT INTO ... SELECT 。
当然你可以使用以下语句来拷贝表结构及数据：
CREATE TABLE 新表
AS
SELECT * FROM 旧表 

INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。
INSERT INTO table2
(column_name(s))
SELECT column_name(s)
FROM table1;

CREATE DATABASE 语句用于创建数据库。
CREATE DATABASE dbname;

CREATE TABLE 语句用于创建数据库中的表。
CREATE TABLE table_name
(
column_name1 data_type(size),
column_name2 data_type(size),
column_name3 data_type(size),
....
);
[数据类型](https://www.runoob.com/sql/sql-datatypes.html)

SQL 约束用于规定表中的数据规则。
如果存在违反约束的数据行为，行为会被约束终止。
约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。
CREATE TABLE table_name
(
column_name1 data_type(size) constraint_name,
column_name2 data_type(size) constraint_name,
column_name3 data_type(size) constraint_name,
....
);
NOT NULL - 指示某列不能存储 NULL 值。
UNIQUE - 保证某列的每行必须有唯一的值。
PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。
FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。
CHECK - 保证列中的值符合指定的条件。
DEFAULT - 规定没有给列赋值时的默认值。

CREATE INDEX 语句用于在表中创建索引。
在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。
注释：更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。
CREATE INDEX index_name
ON table_name (column_name)

通过使用 DROP 语句，可以轻松地删除索引、表和数据库。
ALTER TABLE table_name DROP INDEX index_name
DROP TABLE table_name
DROP DATABASE database_name

仅仅需要删除表内的数据，但并不删除表本身
TRUNCATE TABLE table_name

ALTER TABLE 语句用于在已有的表中添加、删除或修改列。
ALTER TABLE table_name
ADD column_name datatype
ALTER TABLE table_name
DROP COLUMN column_name
ALTER TABLE table_name
MODIFY COLUMN column_name datatype

Auto-increment 会在新记录插入表中时生成一个唯一的数字。
我们通常希望在每次插入新记录时，自动地创建主键字段的值。
CREATE TABLE Persons
(
ID int NOT NULL AUTO_INCREMENT,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
PRIMARY KEY (ID)
)

在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。
视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。
您可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。
注释：视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。
CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition

下面的表格列出了 MySQL 中最重要的内建日期函数：
函数	描述
NOW()	返回当前的日期和时间
CURDATE()	返回当前的日期
CURTIME()	返回当前的时间
DATE()	提取日期或日期/时间表达式的日期部分
EXTRACT()	返回日期/时间的单独部分
DATE_ADD()	向日期添加指定的时间间隔
DATE_SUB()	从日期减去指定的时间间隔
DATEDIFF()	返回两个日期之间的天数
DATE_FORMAT()	用不同的格式显示日期/时间

SQL 函数
SQL 拥有很多可用于计数和计算的内建函数。
SQL Aggregate 函数
SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。
有用的 Aggregate 函数：
AVG() - 返回平均值
COUNT() - 返回行数
FIRST() - 返回第一个记录的值
LAST() - 返回最后一个记录的值
MAX() - 返回最大值
MIN() - 返回最小值
SUM() - 返回总和
SQL Scalar 函数
SQL Scalar 函数基于输入值，返回一个单一的值。
有用的 Scalar 函数：
UCASE() - 将某个字段转换为大写
LCASE() - 将某个字段转换为小写
MID() - 从某个文本字段提取字符，MySql 中使用
SubString(字段，1，end) - 从某个文本字段提取字符
LEN() - 返回某个文本字段的长度
ROUND() - 对某个数值字段进行指定小数位数的四舍五入
NOW() - 返回当前的系统日期和时间
FORMAT() - 格式化某个字段的显示方式


GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。
SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name;

在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。
HAVING 子句可以让我们筛选分组后的各组数据。
where 和having之后都是筛选条件，但是有区别的：
1.where在group by前， having在group by 之后
2.聚合函数（avg、sum、max、min、count），不能作为条件放在where之后，但可以放在having之后
SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name
HAVING aggregate_function(column_name) operator value;

条件判断函数
CASE 字段 WHEN 预期值 THEN 结果1 ELSE 结果2 END
IF(expr,result_true,result_false)
如果查询结果是null，就转换为特定的值，这就要用到Mysql中IFNULL函数。
SELECT IFNULL(price,0) price FROM goods WHERE name='light';
```
![Alt text](数据库%201bedb8930aa6435798e72eadd48d46f1/image.png)


## Redis

****5 种数据表现形式****

- String字符串（主要用于常规计数，粉丝数等）
- Hash散列（用户信息，商品信息等）
- List 列表（消息列表，粉丝列表等）
- Set 集合（共同好友，共同关注等）
- SortedSet有序集合（礼物排行榜等）

****6 种底层数据结构****

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%201bedb8930aa6435798e72eadd48d46f1/Untitled%205.png)

**缓存**

- 分类：只读缓存、读写缓存
- 写入数据库时机：同步写回、异步写回
- 缓存淘汰机制：
    - 随机淘汰（random）
    - LRU（随机选取N个值，然后在这N个值里选择最久未使用的）
    - LFU（使用次数最少）
    - TTL根据过期时间淘汰，越早过期的越删除
- Note：如果数据是干净数据，则直接淘汰，如果数据是脏数据，则需要先写入数据库，然后再进行淘汰，不过Redis 使用的是修改完之后，直接写入数据库，所以不会出现清理缓存的时候出现脏数据的情况。
- 解决缓存和数据库内容不一致的问题
    - 单线程环境下：消息队列
    - 多线程环境下：分布式锁
- 常见问题：缓存穿透，缓存雪崩，缓存击穿、缓存污染
- 缓存的过期删除策略：定期删除、惰性删除

### 集群

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%201bedb8930aa6435798e72eadd48d46f1/Untitled%206.png)

### 持久化

- RDB持久化
- AOF持久化

### 分布式

主要使用两种方法实现并发，`加锁` 和 `原子操作`

### 应用场景

缓存：用来保存热点数据

限时业务：因为我们可以设置淘汰时间，比如验证码，登陆时间等

计数器相关

排行榜：我们可以使用zset

点赞共同好友等

消息队列

### Redis知识点概览
[Redis重要知识点](https://www.yuque.com/bithachi/study/rlw6dw)



## 教材
[数据库系统概论](https://bithachi.blog.csdn.net/article/details/106527797?spm=1001.2014.3001.5502)