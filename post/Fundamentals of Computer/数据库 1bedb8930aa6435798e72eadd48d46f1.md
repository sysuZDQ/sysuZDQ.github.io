# 数据库

目前主流是两个类型的数据库

- 关系型数据库（SQL代表产品MySQL)：Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。因为是纯内存操作，所以Redis 的性能非常出色，是已知性能最快的 key-value 数据库。
- 非关系型数据库（NoSQL代表产品Redis）

[(99条消息) 关系型数据库和非关系型数据库的优缺点和对比_不爱睡觉的程然的博客-CSDN博客](https://blog.csdn.net/cr_lzy/article/details/94961460)

[Hadoop生态圈的核心组件包括哪些 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2082796#:~:text=1%E3%80%81%20Hbase%20%3A%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E5%88%97%E7%9A%84%E5%AD%98%E5%82%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F,%E6%95%B0%E6%8D%AE%E5%BA%93%20%EF%BC%8C%E5%85%B6%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%BAKey-Value%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%BE%BF%E4%BA%8E%E6%89%A9%E5%B1%95%E5%B9%B6%E4%B8%94%E6%9F%A5%E8%AF%A2%E9%AB%98%E6%95%88%E3%80%82%202%E3%80%81Hive%EF%BC%9AHive%E6%98%AFHadoop%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%EF%BC%8C%E4%B9%9F%E6%8F%90%E4%BE%9B%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E3%80%82)

[超全的数据库分类介绍 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/101606473)

[(102条消息) 数据库种类大全及区别_seniorShen的博客-CSDN博客](https://blog.csdn.net/SeniorShen/article/details/100530709)

## MySQL

下载教程

[Windows10 MYSQL Installer 安装（mysql-installer-community-5.7.19.0.msi） | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/windows10-mysql-installer.html)

实践项目

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%201bedb8930aa6435798e72eadd48d46f1/Untitled.png)

下一步考虑部署到服务器

[小白学python爬虫：4.六十行代码爬取NBA数据 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/49947767)

### MySQL内部构造

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%201bedb8930aa6435798e72eadd48d46f1/Untitled%201.png)

****一条 SQL 语句的执行过程****

1.首先进行链接，链接时进行验证，保证安全性，查看执行权限

2.查看缓存，是否有这条语句的执行缓存，如果有缓存则直接返回缓存

3.连接器，分析器（这里查看语法是否有错误），优化器，执行器，搜索引擎

****为什么用 B+ 树做索引****

`二叉搜索树`

当数据是单调递增或递减时，则会退化成链表

`AVL树`

因为维护二叉平衡树的开销比收益要大的多，我们作为索引的数据结构，更多的要求局部，而不是非常严格的平衡的红黑树。不过对于插入较少，查找较多的场景AVL的性能还是较高的。另外AVL树的每个节点只存储一个键值和数据。

`红黑树`

红黑树是一个弱平衡树，但是随着插入数据过多，查询数据时造成的I/O消耗也是巨大的，因为我们很多时候，一次查询并不能将所有数据全部存入内存中，深度过深的话，会加大I/O开销。

B树和B+树的比较在上面

常用的几种索引类型

- 哈希索引：可以直接通过关键字查询到数据，键值对，指定查询效率更高
- 数组索引：数组索引等值查询和范围查询效果较好，但是插入新数据的时候，需要做大量移动，降低性能
- B+树索引：InnoDB的数据都是存储在B+树上的。每一个索引在InnoDB里面对应一棵B+树

最新的MySQL采用的数据引擎事InnoDB，包含两个文件进行存储

`frm` 文件（frame）存储表**结构**；

`.ibd` 文件（InnoDB Data）存储表**索引+数据**。

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%201bedb8930aa6435798e72eadd48d46f1/Untitled%202.png)

**MySQL持久化机制**

**事务**

- 特性：ACID
    
    隔离性：隔离性是通过加锁来实现的，
    
    其他三大特性主要是借助，redo log 和 undo log 来实现的。
    

**锁**

**MVCC**：多版本并发控制，这样每条记录就能够生成一个版本链，每个事务可以查看不同的版本。

**MySQL优化**

`建表优化`

- 尽量使用数字型字段，因为查询和链接时，只需比较一次，效率更快
- 尽量使用varchar少使用char，变长字段空间少，更省空间
- 对于区分度较低的索引，也就是有大量重复的索引，我们可以对其删除。

`查询优化`

- 少使用select * 语句
- 尽量少使用模糊查询 %a
- 不使用 not in ，in，这样会导致走全表索引
- 不实用 a or b 方式进行查询，会使其不走索引
- 尽量少使用子查询（因为需要创建临时表，还需要删除临时表）

`索引优化`

不要创建太多索引，多使用组合索引

对经常 order by 的语句创建索引

**保证幂等性**

一次请求和多次请求造成的结果是一样的，不会因为多次点击而产生副作用。

`高并发情况下保证幂等性`

1.对于insert操作，我们可以这样操作，先通过字段进行搜索，查看是否有该值。如果存在则执行 update或不进行操作，如果没有则 insert。

2.我们可以通过`悲观锁`来实现，我们进行修改前先对其加锁，修改完成后再对其解锁，因为我们有insert 之前先判断的习惯，所以这样就能保证幂等性。

3.使用`乐观锁`来实现，我们给数据加上版本号，修改前如果和第一次查询的版本号一致，则进行修改，同样可以保证幂等性。

4.加`唯一索引`，我们可以通过唯一索引来解决，我们第一次可以添加成功，第二次的时候则不能添加成功。

5.`建立防重表`，可以专门建立一个表，防止重复，这个表里存储的数据只有id和唯一索引的属性组，当我们能够插入防重表时，再通过防重表插入数据库。

6.`根据状态机`这个就是订单生成的位置，通过订单状态来进行一个修改。如果我们第一次修改了状态之后，第二次就无法进行一个修改。

7.通过`分布式锁`，也就是有缓存的情况，通过setnx来对缓存中数据加锁

### SQL命令的执行过程

[阿里二面: 详解一条 SQL 的执行过程 (qq.com)](https://mp.weixin.qq.com/s/OnGaqyUpB58pC2rqqzIzgw)

整体流程

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%201bedb8930aa6435798e72eadd48d46f1/Untitled%203.png)

在存储中查询数据的过程

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%201bedb8930aa6435798e72eadd48d46f1/Untitled%204.png)

1. Buffer Pool 是 MySQL 的一个非常重要的组件，因为针对数据库的增删改操作都是在 Buffer Pool 中完成的
2. Undo log 记录的是数据操作前的样子
3. redo log 记录的是数据被操作后的样子（redo log 是 Innodb 存储引擎特有）
4. bin log 记录的是整个操作记录（这个对于主从复制具有非常重要的意义）

从准备更新一条数据到事务的提交的流程描述

1. 首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中
2. 在数据被缓存到缓存池的同时，会写入 undo log 日志文件
3. 更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中
4. 完成以后就可以提交事务，在提交的同时会做以下三件事
5. （第一件事）将redo log buffer中的数据刷入到 redo log 文件中
6. （第二件事）将本次操作记录写入到 bin log文件中
7. （第三件事）将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记

至此表示整个更新事务已经完成

### InnoDB存储引擎

采用多版本并发控制（MVCC，MultiVersion Concurrency Control）来支持高并发。并且实现了四个标准的隔离级别，通过间隙锁`next-key locking`策略防止幻读的出现。

引擎的表基于聚簇索引建立，聚簇索引对主键查询有很高的性能。不过它的二级索引`secondary index`非主键索引中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。另外InnoDB的存储格式是平台独立。

InnoDB做了很多优化，比如：磁盘读取数据方式采用的可预测性预读、自动在内存中创建hash索引以加速读操作的自适应哈希索引（adaptive hash index)，以及能够加速插入操作的插入缓冲区（insert buffer)等。

InnoDB通过一些机制和工具支持真正的热备份，MySQL 的其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

### 数据库设计三范式

1范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；(只要是关系型数据库都满足1NF)

2范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；

3范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。没有冗余的数据库设计可以做到

### MySQL语言基础
[MySQL语句大全](https://www.yuque.com/bithachi/study/9c72a6a18c85251faf5fd2dabbb0a6e4)

## Redis

****5 种数据表现形式****

- String字符串（主要用于常规计数，粉丝数等）
- Hash散列（用户信息，商品信息等）
- List 列表（消息列表，粉丝列表等）
- Set 集合（共同好友，共同关注等）
- SortedSet有序集合（礼物排行榜等）

****6 种底层数据结构****

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%201bedb8930aa6435798e72eadd48d46f1/Untitled%205.png)

**缓存**

- 分类：只读缓存、读写缓存
- 写入数据库时机：同步写回、异步写回
- 缓存淘汰机制：
    - 随机淘汰（random）
    - LRU（随机选取N个值，然后在这N个值里选择最久未使用的）
    - LFU（使用次数最少）
    - TTL根据过期时间淘汰，越早过期的越删除
- Note：如果数据是干净数据，则直接淘汰，如果数据是脏数据，则需要先写入数据库，然后再进行淘汰，不过Redis 使用的是修改完之后，直接写入数据库，所以不会出现清理缓存的时候出现脏数据的情况。
- 解决缓存和数据库内容不一致的问题
    - 单线程环境下：消息队列
    - 多线程环境下：分布式锁
- 常见问题：缓存穿透，缓存雪崩，缓存击穿、缓存污染
- 缓存的过期删除策略：定期删除、惰性删除

### 集群

![Untitled](%E6%95%B0%E6%8D%AE%E5%BA%93%201bedb8930aa6435798e72eadd48d46f1/Untitled%206.png)

### 持久化

- RDB持久化
- AOF持久化

### 分布式

主要使用两种方法实现并发，`加锁` 和 `原子操作`

### 应用场景

缓存：用来保存热点数据

限时业务：因为我们可以设置淘汰时间，比如验证码，登陆时间等

计数器相关

排行榜：我们可以使用zset

点赞共同好友等

消息队列

### Redis知识点概览
[Redis重要知识点](https://www.yuque.com/bithachi/study/rlw6dw)



## 教材
[数据库系统概论](https://bithachi.blog.csdn.net/article/details/106527797?spm=1001.2014.3001.5502)