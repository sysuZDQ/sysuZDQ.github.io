# 面试-数据库

## MySQL基础操作

- 数据库连接
    - `mysql -h ip -P port -u root -p password`
    - `exit`
- 数据库操作
- 表基本操作

## MySQL索引

### 1、实现

在存储引擎层实现的，因此不同的存储引擎会有不同的实现方式[MyISAM 和 InnoDB 索引的区别 - balfish - 博客园 (cnblogs.com)](https://www.cnblogs.com/balfish/p/8288891.html)，虽然两者都是通过B+树实现的，但是具体实现还是有很大的差别

### 2、类型

- B+树索引
- 哈希索引
- 全文索引
- 空间数据索引

### 3、优化

- 是独立的列
- 使用多列索引
- 让选择性最强的列放在前面
- 使用前缀索引（有些数据类型只检索前缀就可以了）
- 覆盖索引，即索引包含了所有需要查询的字段的值

### 4、创建

- 选择合适的字段
- 频繁更新的不要建立索引
- 多考虑联合索引：[面试官:谈谈你对mysql联合索引的认识? - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/115778804) 最左匹配 + 遇到范围查询停止匹配
- 字符串类型使用前缀索引
- 避免索引冗余
- 小型表不建索引直接检索更快、中大型建立索引，特大型不适合因为维护索引开销太大
- InnoDB使用了聚集索引，即每个叶子节点存储的是整行数据，而不单单是索引

### 5、为什么****用 B+ 树做索引？****

`二叉搜索树`

当数据是单调递增或递减时，则会退化成链表

`AVL树`

因为维护二叉平衡树的开销比收益要大的多，我们作为索引的数据结构，更多的要求局部，而不是非常严格的平衡的红黑树。不过对于插入较少，查找较多的场景AVL的性能还是较高的。另外AVL树的每个节点只存储一个键值和数据。

`红黑树`

红黑树是一个弱平衡树，但是随着插入数据过多，查询数据时造成的I/O消耗也是巨大的，因为我们很多时候，一次查询并不能将所有数据全部存入内存中，深度过深的话，会加大I/O开销。

B树和B+树的比较在上面

常用的几种索引类型

- 哈希索引：可以直接通过关键字查询到数据，键值对，指定查询效率更高
- 数组索引：数组索引等值查询和范围查询效果较好，但是插入新数据的时候，需要做大量移动，降低性能
- B+树索引：InnoDB的数据都是存储在B+树上的。每一个索引在InnoDB里面对应一棵B+树

最新的MySQL采用的数据引擎事InnoDB，包含两个文件进行存储

`frm` 文件（frame）存储表**结构**；

`.ibd` 文件（InnoDB Data）存储表**索引+数据**。

![Untitled](%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%202f23ba10a66e4101884f19081e5d461f/Untitled.png)

## MySQL查询优化

**1**、条件化简

**2**、移除不必要的括号

**3**、常量传递：

1）某个表达式是某个列和某个常量的等值匹配，会直接⽤常量替换列名

**4**、移除没⽤的条件：

1）⽐如永远为true或false：

**5**、表达式计算：

1）表达式只包含常量的话，值会被计算出来

2）如果某个列在函数中或者以运算形式出现，优化器不会进⾏化简 

**6**、**having**和**where**⼦句的合并：

1）查询语句中没有sum、max这样的聚集函数以及group⼦句的话，优化器会将having和

where⼦句合并

2）having⼦句⽤于分组后过滤，where⽤于分组前合并

**7**、常量表检测：

1）使⽤主键等值匹配、使⽤唯⼀⼆级索引列等值匹配进⾏查询的表称为常量表

2）优化器会优先执⾏常量表查询，因为速度⾮常快

**8**、外连接消除

**9**、优化器会将右连接转换为左连接查询

**10**、空值拒绝

1）在外连接查询中，指定的where⼦句中包含被驱动表的列不为null值的条件（就是不

允许查出来的记录中含有null值）

2）被驱动表的where⼦句符合空值拒绝的条件后，外连接和内连接可以相互转换

**11**、⼦查询优化

附：MySQL优化类型

`建表优化`

- 尽量使用数字型字段，因为查询和链接时，只需比较一次，效率更快
- 尽量使用varchar少使用char，变长字段空间少，更省空间
- 对于区分度较低的索引，也就是有大量重复的索引，我们可以对其删除。

`查询优化`

- 少使用select * 语句
- 尽量少使用模糊查询 %a
- 不使用 not in ，in，这样会导致走全表索引
- 不实用 a or b 方式进行查询，会使其不走索引
- 尽量少使用子查询（因为需要创建临时表，还需要删除临时表）

`索引优化`

不要创建太多索引，多使用组合索引

对经常 order by 的语句创建索引

## MySQL存储引擎

- InnoDB
    
    采用多版本并发控制（MVCC，MultiVersion Concurrency Control）来支持高并发。并且实现了四个标准的隔离级别，通过间隙锁`next-key locking`策略防止幻读的出现。
    
    引擎的表基于聚簇索引建立，聚簇索引对主键查询有很高的性能。不过它的二级索引`secondary index`非主键索引中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。另外InnoDB的存储格式是平台独立。
    
    InnoDB做了很多优化，比如：磁盘读取数据方式采用的可预测性预读、自动在内存中创建hash索引以加速读操作的自适应哈希索引（adaptive hash index)，以及能够加速插入操作的插入缓冲区（insert buffer)等。
    
    InnoDB通过一些机制和工具支持真正的热备份，MySQL 的其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。
    
- MyISAM

## MySQL分表分库

### 1、原因

1）单库太⼤

单个数据库处理能⼒有限，所在的服务器上的磁盘空间也有限，单库存在I/O操作瓶颈。

主要⽅案：切分成更多更⼩的库 

**2）**单表太⼤

CRUD都成问题，索引膨胀，查询超时。

主要⽅案：切分成多个数据集更⼩的表

### 2、拆分方案

**1**、垂直拆分

1）垂直分表

1. “⼤表拆⼩表“，基于列的字段进⾏

2. ⼀般表中字段较多，将不常⽤的，数据较⼤的，长度较长的，拆分到“扩展表”

2）垂直分库

1. ⼀般情况下，针对⼀个系统中不同业务进⾏拆分

2. ⼀般我们拆分之后，放到多个服务器上

**2**、⽔平拆分

1）⽔平分表

针对数据量巨⼤的单张表（⽐如订单），按照某种规则（RANGE，HASH取模），切分到多

张表中，这些表还在⼀个数据库中

2）⽔平分库

将单张表的数据切分到多个服务器上，每个服务器都有相应的库和表，只是表中的数据集合

不同

⽔平分库能够有效的缓解单机和单库的性能瓶颈，I/O，连接数和硬件资源等瓶颈

3）⽔平分库分表切分规则：

**range**： 根据范围，⽐如0-1000⼀个表，1001到2000⼀个表

**hash**取模： ⽐如取ID，进⾏hash取模，根据模数分配到不同的数据库中

地理区域： 按照地理范围进⾏划分

时间范围： 按照时间进⾏切分

## MySQL数据类型

## MySQL复制

### 1、概念

数据可以从⼀个MySQL数据库服务器主节点复制到⼀个或者多个从节点。
MySQL默认采⽤异步复制⽅式，这样从节点就不⽤⼀直访问主服务器来更新最新数据。
从节点可以复制主节点数据库中的所有数据库、特定的数据库或者特定的表。

### 2、用途

- 数据实时备份
- 读写分离
- 架构扩展

## MySQL日志

### 1、三大日志

- binlog
    - 功能：记录语句原始逻辑、用于数据备份
    - 三种格式：statement, row, mixed
    - 写入机制：事务的binlog不能拆开，事务执行时，写到binlog cache，提交时，写到binlog
- redo log
    - 功能：更新表时，会把修改记录写到redo log buffer，然后看策略刷盘到redo log，当mysql实例宕机了，可以借助redo log恢复数据
    - 刷盘时机：buffer空间不足、事务提交、后台线程以一定频率进行刷盘、正常关闭服务器
- undo log
    - 功能：所有的修改都会被记录，当发生问题就可以回滚

## MySQL锁

### 1、作用

多个事物在并发情况下会出现⼀些经典的问题，如脏读、不可重复读、幻读、丢失更新。为
了不同程度的解决这些问题，出现了不同的隔离级别，锁就是实现各种隔离级别的⼀种方式。

### 2、分类

类型：表锁、行锁（在 InnoDB 事务中，⾏锁是在需要的时候才加上的，但并不是不需要了就⽴刻释放，⽽是要等到事务结束时才释放。这个就是两阶段锁协议。）

模式：AUTO-INC、共享/排它锁（读/写锁）、读/写意向锁（给更⼤⼀级别的空间⽰意⾥⾯是否已经上过锁）

思想：乐观锁（认为对同⼀数据的并发操作不会总发⽣，属于⼩概率事件，不⽤每次都对数据上锁，也就是 不采⽤数据库⾃⾝的锁机制，⽽是通过程序来实现。在程序上，我们可以采⽤版本号机制或
者时间戳机制实现。）、悲观锁（也是⼀种思想，对数据被其他事务的修改持保守态度，会通过数据库⾃⾝的锁机制来实现， 从⽽保证数据操作的排它性。）

### 3、加锁规则

包含了两个“原则”、两个“优化”和⼀个“bug”

两个原则：

1. 加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区

间。

2. 查找过程中访问到的对象才会加锁。

两个优化：

1. 索引上的等值查询，给唯⼀索引加锁的时候，next-key lock 退化为⾏锁。

2. 索引上的等值查询，向右遍历时且最后⼀个值不满⾜等值条件的时候，next-key

lock 退化为间隙锁。

⼀个**"bug"**：

1. 唯⼀索引上的范围查询会访问到不满⾜条件的第⼀个值为⽌。（MySQL8.0之后的

版本已经修复）

## MySQL事务

### 1、概念

⼀个最⼩的不可再分的⼯作单元（需要保证ACID的一个或多个数据库操作），通常情况下，⼀个事务对应⼀个完整的业务。MySQL原⽣引擎MyISAM不⽀持事务，所以被InnoDB取代

### 2、特性（ACID）

**1**、**A** 原⼦性（**Atomicity**）

⼀个事务的所有操作，要么全部完成，要么都没完成，不能结束在中间环节。如果事务在执

⾏过程中发⽣错误，会被回滚到事务开始之前的状态

**2**、**C** ⼀致性（**Consistency**）

在事务开始之前以及事务结束之后，数据库的完整性不能被破坏

**3**、**I** 隔离性（**Isolation**）

允许多个并发事务同时对数据进⾏修改和读写的能⼒，它可以防⽌由于多个事务并发执⾏时

由于交叉执⾏⽽导致的数据不⼀致

**4**、**D** 持久性（**Durability**）

事务处理结束了以后，对数据的修改是永久的，即使是发⽣了系统故障，数据也不会丢失

### 3、事务四大隔离级别

这4种隔离级别，并⾏性能依次降低，安全性依次提⾼。

**1**、**RU** 读不提交（**Read Uncommited**）

在该隔离级别下，事务之间完全不隔离，会产⽣脏读，⼀般情况不会使⽤

**2**、**RC** 读提交（**Read Commited**）

本事务读取到的是其它事务提交的最新数据，但有⼀个问题在同⼀个事务中，前后两相同的

select可能会读到不同的结果

**3**、**RR** 可重复读（**Repeatable Read**）

在同⼀个事务中，select的结果是事务开始时时间点的状态，因此，同⼀个事务同样的

select操作可以读到⼀致的结果

**4**、**serializable**串⾏化

读操作会隐式获取共享锁，保证不同事务之间的互斥

数据库对隔离级别的实现
DB会创建⼀个视图
可重复读： 视图在事务启动时创建，整个事务存在期间都⽤这个视图。
读已提交： 视图在每个SQL语句开始执⾏的时候创建的。
读未提交： 直接返回记录上的最新值，没有视图概念

串⾏化：     直接⽤加锁的⽅式来避免并⾏访问

数据并发问题

脏写：对于两个事务 `Session A`、`Session B`，如果事务`Session A` 修改了另一个未提交事务`Session B` 修改过的数据，那就意味发生了脏写

脏读：对于两个事务`Session A`、`Session B`，`Session A`读取了已经被 `Session B`更新但还没有被提交的字段。之后若`Session B` 回滚，`Session A`读取的内容就是临时且无效的。

不可重复读：对于两个事务`Session A`、`Session B`，`Session A`读取了一个字段，然后`Session B` 更新了该字段。之后`Session A`再次读取同一个字段，值就不同了。那就意味着发生了不可重复读

幻读：对于两个事务`Session A`、`Session B`,`Session A` 从一个表中读取 了一个字段,然后 `Session B`在该表中 插入了一些新的行。之后,如果 `Session A` 再次读取同一个表，就会多出几行。那就意味着发生了幻读。我们把新插入的那些记录称之为 幻影记录

## MySQL表连接

pass

## 数据库排序

在分割段的阶段，使⽤内部排序，⽣成n个⼤⼩等于可⽤内存的顺串，最后再进⾏归并，使

得数据整体有序。

但是，为了避免**I/O**操作带来的影响，所以使⽤替换**-**选择排序的⽅式，可以使得在分割段阶

段⽣成的顺串⼤⼩⼤于可⽤内存⼤⼩。

同时为了能够再次减⼩I/O开销，合并阶段，可适量的增加归并的路数

不过增⼤路数也就意味着内部每个缓冲区数量增加（⼀个缓冲区放⼀个顺串），每次要在更

多的缓冲区中选取最⼩值，所以引⼊败者树（和堆排很像），减少增加归并路数，⽽影响内

部归并。

## MySQL高性能

- MySQL主从复制
- 分库分表

## MySQL语句执行

### 查询语句运行

**1**、连接器

负责跟客户端建⽴连接、获取权限、维持和管理连接

Mysql 会定期⾃动清理"空闲"连接，由参数 wait_timeout 控制的，默认值是 8 ⼩时。

由于建⽴连接⽐较复杂，所以尽量使⽤长连接，⽽不是 短连接（少量查询后，就断开连接)

但是，当 长连接 过多时，可能导致内存占⽤太⼤，被系统强⾏杀掉（OOM），即会导致

MySQL 异常重启

解决⽅案为**:**

1. 定期断开长连接

2. MySQL 5.7以后版本，可以通过执⾏ mysql_reset_connection 来重新初始化连接资

源

**2**、查询缓存

执⾏查询语句前，先看下查询缓存中是否有结果

如果有，则不必执⾏查询语句，直接取出缓存结果

如果没命中缓存，则执⾏查询语句，并将执⾏查询语句后的结果，放⼊查询缓存中

Note: 不建议使⽤查询缓存（当 数据表频繁更新时，最新查询结果可能和查询缓存中存放的

结果不⼀致)

MySQL 8.0 版本直接将查询缓存的整块功能删掉

**3**、分析器

1. 词法分析2. 语法分析

**4**、优化器

优化器是在表⾥⾯有多个索引的时候，决定使⽤哪个索引；或者在⼀个语句有多表关联

（join）的时候，决定各个表的连接顺序

**5**、执⾏器

执⾏语句时，⾸先判断当前⽤户是否有执⾏权限

如果没有执⾏权限，则终⽌

- 如果有执⾏权限，则执⾏器就会根据表的引擎定义，去使⽤这个引擎提供的接

⼜。

![Untitled](%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%202f23ba10a66e4101884f19081e5d461f/Untitled%201.png)

附：更为详细的流程

整体流程

![Untitled](%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%202f23ba10a66e4101884f19081e5d461f/Untitled%202.png)

在存储中查询数据的过程

![Untitled](%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E5%BA%93%202f23ba10a66e4101884f19081e5d461f/Untitled%203.png)

1. Buffer Pool 是 MySQL 的一个非常重要的组件，因为针对数据库的增删改操作都是在 Buffer Pool 中完成的
2. Undo log 记录的是数据操作前的样子
3. redo log 记录的是数据被操作后的样子（redo log 是 Innodb 存储引擎特有）
4. bin log 记录的是整个操作记录（这个对于主从复制具有非常重要的意义）

从准备更新一条数据到事务的提交的流程描述

1. 首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中
2. 在数据被缓存到缓存池的同时，会写入 undo log 日志文件
3. 更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中
4. 完成以后就可以提交事务，在提交的同时会做以下三件事
5. （第一件事）将redo log buffer中的数据刷入到 redo log 文件中
6. （第二件事）将本次操作记录写入到 bin log文件中
7. （第三件事）将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记

至此表示整个更新事务已经完成

### 更新语句执行

**1**、**redo log VS. binlob** (3点不同)

1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使⽤。

2. redo log 是物理⽇志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑⽇志，记录的是这个语句的原始逻辑，⽐如“给 ID=2 这⼀⾏的 c 字段加 1

3. redo log 是循环写的，空间固定会⽤完；binlog 是可以追加写⼊的。“追加写”是指binlog ⽂件写到⼀定⼤⼩后会切换到下⼀个，并不会覆盖以前的⽇志。

**2**、数据恢复

先找到最新的全量备份，恢复之；然后，依次执⾏该全量备份以后得所有 binlog

**3**、为什么必须有两阶段提交呢？

这是为了让两份⽇志之间的逻辑⼀致性

## MySQL用户管理

### 1、目的

为了保证MySql服务器的安全，每个MySql的⽤户应该对他们需要的数据具有适当的
访问权;

### 2、类型

- ⽤户账号存储：`use mysql select user from user`
- ⽤户账号管理：`CREATE USER [user_name] IDENTIFIED BY [user_pwd]`
- ⽤户账号删除：`DROP USER [user_name]`
- ⽤户权限控制：`GRANT [权限名] ON [数据库名].[表名] TO [⽤户名]` `REVOKE [权限名] ON [数据库名].[表名] FROM [⽤户名]`

## MySQL分布式

## 数据库设计三范式

1范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；(只要是关系型数据库都满足1NF)

2范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；

3范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。没有冗余的数据库设计可以做到